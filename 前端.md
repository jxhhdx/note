# ES6

## let、const

```javascript
// 块级作用域（let、const）
// 重新被声明（let、const）
// 不存在变量提升（let、const）
console.log(aa); // undefined var 定义变量的时候会最先执行var aa段，所以这时会是未定义
var aa = 'nice'
// 暂存死区
var nice = "hello1"
{
    console.log(nice); // 全局作用域中定义过nice，但是由于nice在块级作用域中也定义了，所以这种情况就是暂时锁区
    let nice = "hello2"
}
console.log(nice);
// q:生成十个按钮，每个按钮点击的时候弹出1-10
// var i = 0;
// for (i = 0; i < 10; i++) {
//     (function (i) {
//         var btn = document.createElement('button')
//         btn.innerText = i
//         btn.onclick = function name(params) {
//             alert(i)
//         }
//         document.body.appendChild(btn)
//     })(i)
// }

for (let i = 0; i < 10; i++) {
    var btn = document.createElement('button')
    btn.innerText = i
    btn.onclick = function name(params) {
        alert(i)
    }
    document.body.appendChild(btn)
}
// q：如何解决const引用类型可以被修改的问题
Object.freeze() // 可以使引用不会被改变
// ES6之前如何声明常量
Object.defineProperty(CST, 'BASE_NAME', {
    value:'小明',
    writable: false
}) // 保证属性不会修改
Object.seal() // 保证属性不会被拓展
Object.defineProperty(Object, 'freezePolyfill', {
    value: function (obj) {
        var i;
        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                Object.defineProperty(obj, i, {
                    writable: false
                })
            }
        }
        Object.seal(obj)
    }
})

let xiaoming = {
    age: 18,
    name: 'javon'
}
Object.freezePolyfill(
    xiaoming
)
```

## 解构赋值

+ 解构赋值是JavaScript的一个表达式，使得可以将值从数组或者属性中提取到不同的变量

```javascript
// 数组的解构赋值
const arr = [1,2,3,4];
let [a,b,c,d] = arr; // a = 1,b = 2...
const arr1 = [1,2,[3,4,[5,6]]]
const [ , , [, ,[, g]]] // g = 6
// 扩展运算符
const arr1 = [1,2];arr2 = [3,4]; arr3 = [ 5, 6];
const arr4 = [...arr1,..arr2,...arr3] // arr4 = [1,2,3,4,5,6]
const arr5 = [1,2,3,4];
const [a,b,...c] = arr5 // c = [3,4]，这时...必须在最后
// 默认值
// const arr = [1, undefined, undefined]
// const arr = [a, b = 3, c , d = 'aaa'] // a = 1, b = 3, c = undefined,  d = 'aaa'

// 交换变量
[a, b] = [b, a]

// 接收多个 函数返回值
function getUserInfo(id) {
    return [
        true,
        {
            name:'小明'，
            gender:'女'，
            id: id
        },
        '请求成功'
    ] 
}
const [status, data, msg] = getUserInfo(123)
// 对象解构赋值
// 字符串解构赋值
// 函数参数解构赋值
// 数值和布尔值解构赋值
```

## 字符串拓展


# Vue

## 指令
```javascript
v-cloak 
v-text
v-html  // 用来说明定义的值为html格式
"v-bind："缩写是"："  // 用来说明属性的中值为变量
v-on //缩写是"@"  // 绑定事件
v-model  // 双向数据绑定
v-for  // 迭代
```

属性

```javascript
el // 用来选中
data // 用来定义数据
methods // 用来定义方法
filters // 用来定义过滤器
directives // 用来定义私有指令
component // 用来定义组件
```

## 事件修饰符
```javascript
.stop // 阻止事件冒泡
.prevent // 阻止默认行为
.capture // 添加事件监听器使用事件捕获模式
.self // 只当是元素本事触发的时候执行，子元素不触发
.once // 事件只触发一次
```

## 使用class样式
```html
<!--数组-->
<h1 :class="['red','thin']">这是一个邪恶的H1</h1>
<!--数组中使用三目运算符-->
<h1 :class="['red','thin',isactive?'active':'']"></h1>
<!--数组中使用嵌套对象-->
<h1 :class="['red','thin',{'active':isactive}]"></h1>
<!--直接使用对象-->
<h1 :class="['red','thin',{'active':isactive}]"></h1>
```

## 生命周期
```javascript
beforeCreate()
created()

beforeMount()
mounted()

beforeUpdate()
updated()

beforeDestroy()
destroy()
```

## v-resource
https://github.com/pagekit/vue-resource

## Vue提供的标签
?    component template transition transitionGroup



## Vue路由安装

```shell
npm install vue-router # 安装路由器
## 再main.js文件中导入配置即可全局使用
import VueRouter from 'vue-router'
Vue.use(VueRouter)
```



# React
## 概述
- react是一个用于构建用户界面的javascript库，它由facebook以及个人开发者和公司组成的社区开发。它拥有较高的性能，代码逻辑非常简单。

## JSX
- JSX是React的核心部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套.

## 组件
- 组件可以是的使得页面的开发变得更加灵活，代码复用率高。自由组合开发的组件。

​    eg：

```javascript
  var Hello = React.createClass({
        render: funcation() {
            return <h1>Hello {this.props.name}</h1>;
        }
  });
  ReactDOM.render(
      <HelloMessage name = "W3CSchool" />,
      document.getElementById('example')
 );   
```



## state
```javascript
    getInitialState:funcation() {
        return {liked:fales};
    }
```

## React组件API
        设置状态：setState
        替换状态：replaceState
        设置属性：setProps
        强制更新：forceUpdate
        获取DOM节点：finDOMNode
        判断组件挂载状态：isMounted

## 生命周期方法
```javascript
    componentWillMount 在渲染前调用,在客户端也在服务端
    componentDidMount : 在第一次渲染后调用，只在客户端。
    componentWillReceiveProps 在组件接收到一个新的prop时被调用。
    shouldComponentUpdate 返回一个布尔值。
    componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。
    componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。
    componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。
```

## 路由

+  http://react-guide.github.io/react-router-cn/docs/Introduction.html 

# 实践（React小游戏）

 [井字棋小游戏]( https://zh-hans.reactjs.org/tutorial/tutorial.html )

## 1、环境搭建

```shell
npx create-react-app my-app  # 搭建环境
del *  # windows清除src下的目录时使用
npm start  # 启动
```

## 2、项目开发

### 开发基础（react之Class的书写形式）

+ 如下是render方法返回组件

```react
class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}
```

+ 等价于如下的代码：

```react
React.createElement("div", {
  className: "shopping-list"
},  React.createElement("h1", null, "Shopping List for ", props.name), 
	React.createElement("ul", null, 
		React.createElement("li", null, "Instagram"), 
		React.createElement("li", null, "WhatsApp"), 
		React.createElement("li", null, "Oculus")
	)
);
```

### 开发基础（react之参数传递父传子）

+ react使用Props来进行参数的传递，使用`this.props.value`从父类中获取属性，如下是父组件传递参数。

```react
class Board extends React.Component {
  renderSquare(i) {
    return <Square value={i} />;
  }
}
```

+ 子组件获取参数

```react
class Square extends React.Component {
  render() {
    return (
      <button className="square">
        {this.props.value}
      </button>
    );
  }
}
```

### 开发基础（react之保存数据）

+ 给类创建构造函数，并使用super（props）就可以使用`this.state = {value: null,}`定义需要保存的数据。
+ 查时this.state.value`
+ 改时`this.setState({value: xxx})`

```react
class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }
  render() {
    return (
      <button className="square" onClick={() => alert('click')}>
        {this.props.value}
      </button>
    );
  }
}
```

### 开发基础（react之浏览器插件安装）

+ 应用商店自行安装（安装之后可以查看组件树）

### 开发基础（react之参数传递子传父）

+ 子组件传递参数的思路是，父组件给子组件传递一个函数，子组件通过父组件给予的函数修改父组件的状态。，如下代码是父组件：

```react
class Board extends React.Component {

    constructor(props){
        super(props);
        this.state = { squares: Array(9).fill(null),}
    }
    // 给子组件传递函数
    renderSquare(i) {
        return <Square value={this.state.squares[i]} onClick={() => this.handleClick(i)}/>;
    }

    handleClick(i) {
        const squares = this.state.squares.slice()
        squares[i] = 'X'
        this.setState({squares: squares})
    }

    render() {
        const status = 'Next player: X';
        return (
            <div>
                <div className="status">{status}</div>
                <div className="board-row">
                    {this.renderSquare(0)} <!--同上x2-->
                </div>
                <!--同上x2-->
            </div>
        );
    }
}
```

+ 如下是子组件调用父组件的函数，并且传参

```react
class Square extends React.Component {
    render() {
        return (
            <button  className="square"  onClick = {() => this.props.onClick()}>
                {this.props.value}
            </button>
        );
    }
}
```

### 开发基础（react之类的简写）

+ 将class Square转化为function Square

```react
// class Square extends React.Component {
//     render() {
//         return (
//             <button 
//                 className="square" 
//                 onClick = {() => this.props.onClick()}>
//                 {this.props.value}
//             </button>
//         );
//     }
// }
function Square(props) {
    return (
        <button className="square" onClick={props.onClick}>
            {props.value}
        </button>
    );
}
```



## 3、项目部署